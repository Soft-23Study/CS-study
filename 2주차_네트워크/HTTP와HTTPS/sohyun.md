# HTTP & HTTPS

### HTTP & HTTPS

- HTTP
    - ****HyperText Transfer Protocol****
    - 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
    - 텍스트 교환 ← 단순히 HTML을 클라이언트와 서버가 주고 받는 것
    - 만약 악의적인 사용자가  네트워크 신호를 가로챈다면?
        - 정보 가로채 조작하거나 없애 버리는 등에 공격 가할 수 있음
        - 보안적인 부분에서 문제 발생 ⇒ 보안에 취약
    
- HTTPS
    - ****HyperText Transfer Protocol Secure**
    - HTTP에 보안 문제 해결 (SECURE)
        - HTML 정보를 암호화 시켜 외부 사용자로부터 데이터 지키는 것
    - SSL 프로토콜 사용하여 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
    - 
    
    ```python
    # SSL
    - Secure Socket Layer
     : TCP/IP 네트워크에서 통신할 때 사용되는 암호화 기반 프로토콜
       (전송 계층 프로토콜)
    : TCP, UDP와 같은 일반적인 인터넷 통신에 안전한 계층을 추가하는 방식
    ```
    
    - SSL 인증서
        - 클라이언트와 서버 간의 통신을 제 3자가 보증화 해주는 전자화된 문서
        - 통신 내용이 공격자에게 노출되고 악의적으로 변경되는 것을 막아 신뢰성 높임
        - 인증서의 목표
            1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버인지 판단
            2. SSL 통신에 사용될 공개키를 클라이언트에 전달
        - SSL 인증서에 들어갈 내용
            1. 서비스의 정보 (CA, 도메인)
            2. 서버 측 공개키
    
    - 텍스트를 암호화함 / 공개키 암호화 방식으로
    
    ```python
    공개키 암호화 방식
    공개 키 : 누구에나 공개되어 모두가 접근이 가능한 키
    개인 키 : 본인을 제외한 누구도 접근이 불가능한 키
    ```
    

- HTTPS 통신 흐름
    1. 기업(A) 서버는 공개키와 개인키를 만듬
    2.  믿을만한 저장소(CA 기업)와 계약해 두 키를 관리하도록 함
    
    ```
    CA ? 
    Certificate Authority 인증 기관
    공개키를 저장해주는 신뢰성이 검증된 민간 기업
    ```
    
    1. CA 기업은 기업(A)이름 , 서버의 공개키 , 공개키 암호화 방법 담은 인증서 만듦
    2. 암호화한 인증서를  A서버에 제공
    
    ```
    만약 클라이언트가 main.html A서버에 요청
    -> https 요청이 아니면 개인키로 암호화된 인증서를 받게 됨
    ```
    
    1. 브라우저는 암호화된 인증서를 A 서버의 공개키 얻게 됨
    2. 클라이언트가 A서버와 HandShaking 하면서 주고 받은 난수를 조합해 대칭키 생성
    3. A서버의 공개키로 해당 대칭키 암호화 하여 서버로 보냄
    4. A서버는 암호화된 대칭키를 자신의 개인키로 복호화 →  클라이언트와 같은 대칭키 얻음
    5. 이후 클라이언트-서버사이의 통신을 할 때 주고받는 메세지는 이 pre-master-key(대칭키)를 이용하여 암호화, 복호화를 진행
