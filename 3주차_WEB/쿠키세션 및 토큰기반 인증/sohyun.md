# 쿠키, 세션 / 토큰 기반 인증

### 쿠키 세션을 사용하는 이유 ?

- HTTP프로토콜의 특징이자 약점인 부분을 보완하기 위해서
    - HTTP 프로토콜 특징1 : Connectionless 프로토콜 (비연결 지향)
        - 클라이어트가 서버에 요청했을 때 응답 보낸후 연결 끊는 처리 방식
    - HTTP 프로토콜 특징2 : Stateless 프로토콜
        - 커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나고
        - 상태 정보는 유지하지 않음
- 정보가 유지 되지 않으면
    - 페이지 이동할때마다 로그인 다시
    - 상품 선택했는데 구매 페이지에 선택한 상품 정보 없음 등의 일이 발생 가능
- ⇒ 이를 대처하기 위해 쿠키 / 세션 사용

### 쿠키

- 어떤 웹사이트 방문 시에
- 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 정보 기록 파일
- 클라이언트에 pc로 저장하였다가 필요시에 정보를 참조하거나 재사용

- 특징 (세션과 함께 아래서)
- 동작 순서
    1. 클라이언트 : 페이지 요청한다 (= 웹사이트 접근)
    2. 웹서버 : 쿠키 생성
    3. 생성한 쿠키에 정보를 담아서 HTTP화면 돌려줄때 쿠키 정보도 클라이언트에게 돌려줌
    4. 클라이언트는 쿠키를 들고 있다가(로컬에 저장한 상태) 다시 서버에 요청할때 쿠카와 함께 전송
    5. 동일 사이트를 다시 방문할때 pc에 쿠키가 있는  경우
        1. 요청 페이지와 함께 쿠키 전송
- 사용 예시
    - 방문 사이트에서 로그인할때 `아이디 비밀번호 저장하시겠습니까?` 나오면 쿠키에 저장
    - 팝업창으로 `오늘 이 창 다시 보지않기` 체크

### 세션 Session

- 일정 시간 동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지 시키는 것

```
일정 시간 ? 
방문자가 웹브라우저를 통해 웹 서버에 접속 시점 ~ 웹브라우저 종료하여 연결 끝내는 시점
```

- 특징 (아래서)
- 동작 순서
    1. 클라이언트가 페이지 요청
    2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 
        1. 클라이언트가 해당 session-id를 보냈는지 확인한다.
    3. session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 넘겨준다.
    4. 클라이언트는 서버로부터 받은 session-id를 쿠키에 저장한다.
        
        `여기서 쿠키는 웹서버에 저장되는 쿠키인 세션 쿠키`
        
    5. 클라이언트는 서버에 요청시 이 쿠키의 session-id 값을 같이 서버에 전달한다.
    6. 서버는 전달받은 session-id로 session에 있는 클라이언트 정보를 가지고 요청을 처리 후 응답한다.
- 사용 예시
    - 화면 이동해도 로그인 풀리지 않고 로그아웃 전까지 일정 시간 유지

### 쿠키 세션 비교

- 상태 정보와 저장 위치에서 차이점 발생
- 쿠키는 클라이언트에 저장 , 세션은 서버에 저장


### **저장 위치**

- 쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크
- 세션 : 서버의 메모리에 저장

### **만료 시점**

- 쿠키 : 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜 정할 수 있음
- 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화 되기 때문에 정확한 시점 알 수 없음

### **리소스**

- 쿠키 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음
- 세션 : 세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함

### **용량 제한**

- 쿠키 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자 한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠
- 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음

### 보안 : 세션 > 쿠키

### 보안상 모두 세션을 쓰면 되는데 쿠키를 사용하는 이유

- 세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원도 많아지게 되므로 쿠키와 세션을 적절하게 사용하여, 서버 자원의 낭비를 방지할 수 있다.

### **캐시(Cache)?**

- 웹 페이지 요소를 저장하기 위한 임시 저장소이고,
- vs ) 쿠키/세션은 정보를 저장하기 위해 사용된다.
    
    
- 웹 페이지를 빠르게 렌더링 할 수 있도록 도와줌
- vs ) 쿠키/세션은 사용자의 인증을 도와준다.

- 캐시는 이미지, 비디오, 오디오, css, js파일 등 데이터나 값을 미리 복사해 놓는 리소스 파일들의 임시 저장소이다.
- 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다.
- 같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 된다.
- 이전에 사용된 데이터가 다시 사용될 가능성이 많으면 캐시 서버에 있는 데이터를 사용한다.
- 그래서 다시 사용될 확률이 있는 데이터들이 빠르게 접근할 수 있어진다. (페이지의 로딩 속도 ↑)



## 토큰 기반 인증 방식

- 토큰 기반 인증은 stateful 서버와 반대적 개념인 stateless 서버를 사용하며
- 상태 정보를 유지하지 않는다.
- 서버가 전달받은 토큰을 검증만 하면 되기 때문에 서버의 부담을 줄이고 서비스의 확장성을 높일 수 있다.

- 인증 방식
    1. 사용자 로그인 (로그인 정보를 서버로 요청)
    2. 서버는 요청이 들어오면 사용자 검증, 유효하다면 정상적으로 발급된 토큰을 클라이언트에 반환
    3. 클라이언트는 토큰을 저장
    4. 서버에서 요청 시에 해당 토큰을 Request header에 담아 서버에 전달
    5. 서버는 받은 토큰을 검증 후 요청에 응답

- 특징
    - 유지하고 저장하는게 서버 기반 인증 방식이라면
    - 토큰 기반 방식은 서버 상태 유지 X ⇒ 부하 적고 확장성 높음
    
    - 단점  : 토큰 강제 만료 불가능
        - 만약 토큰이 해킹당하면 해커는 만료될때까지 마구 이용
        - 그래서 AccessToken과 RefreshToken을 함께 발급
            - 보통 Access Token은 20~30분, Refresh Token은 한달 정도의 만료 기간을 부여
        - 클라이언트는 AccessToken이 만료되었다는 오류를 받으면
            - 따로 저장해두었던 RefreshToken을 이용하여 AccessToken의 재발급을 요청
        - 서버는 유효한 RefreshToken으로 요청이 들어오면 새로운 AccessToken을 발급
        - 만료된 RefreshToken으로 요청이 들어오면 오류를 반환해, 사용자에게 로그인을 요구하게 된다.
        
        ```
        여기서, 
        AccessToken은 서버에 따로 저장해 둘 필요가 없지만, 
        RefreshToken의 경우 서버의 stroage에 따로 저장
        
        Access Token 재발급 요청을 위한 것이다. 
        이때, RefreshToken은 탈취되어서는 곤란하므로 
        클라이언트는 보안이 유지되는 공간에 이를 저장해두어야 한다. 
        물론 Refresh Token은 서버에서 따로 저장하기 때문에
        강제로 토큰을 만료시키는 것이 가능해짐.
        ```
        

### JWT (****JSON Web Token)****

- 인터넷 표준 인증 방식
- 토큰 기반 인증 방식의 대표적인 방법

- 구성 요소
    - 구분자 : `.`
    - aaaa.bbbbb.ccccc 의 구조로 앞부터 헤더(header), 내용(payload), 서명(signature)로 구성

- 헤더
    - 토큰 타입 / 해싱 알고리즘(토큰 검증하는 부분인 signature시 사용) 지정
    
    ```
    {
      "typ": "JWT",
      "alg": "HS512"
    }
    ```
    

- payload
    - claim 사용자나 토큰에 대한 property 를 key-value 형태로 저장
    
    ```
    {
      "sub": "1",
      "iss": "ori",
      "exp": 1636989718,
      "iat": 1636987918
    } // 각각을 외우고 면접에 들어가진 않을거같아서 생략 알고싶다면
    https://velog.io/@jinyoungchoi95/JWTJson-Web-Token-%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D
    참고
    ```
    
    - 여기서 명심해야하는 것 페이로드에는 민감한 정보 담지 않는다
        - 헤더와 페이로드는 json 디코딩이 되어있는 것이지 특별한 암호화 결려있지 않음
    - 왜 암호화 하지 않았는가
        
        그래서 JWT는 단순히 "식별을 하기위한" 정보만을 담아두어야하는 것입니다.
        
        > 간혹 JWT의 header나 payload가 식별값만 존재하지만 해당 값들도 암호화를 통해 감추어야하지 않느냐는 생각을 가졌을 때가 있습니다.
        > 
        > 
        > 예를 들어 base64UrlEncode(암호화(header)).base64UrlEncode(암호화(payload)).signature(암호화된 이 둘을 또 암호화)와 같은 형태였습니다.
        > 
        > 제가 생각했던 방법이지만 사실 필요없는 행위입니다. 암호화는 민감한 정보를 막아두어야할 때는 필요한 행위이지만 이 자체만으로도 많은 리소스를 사용하기 때문에 신중하게 사용해야합니다. 매 http 요청마다 한번의 복호화가 더 추가되는 셈이니까요.
        > 
        > 그렇기 때문에 유출되었을 때 그렇게 큰 상관이 없는 비민감정보를 토큰에 담는 것이 기본 스펙이 되는 것이고, 서버는 굳이 header나 payload를 암호화하지 않아도 되는 것입니다.
        > 

- Signiture 서명
    - 서명은 헤더의 인코딩값과 정보의 인코딩값을 합친후 주어진 비밀키로 해쉬를 하여 생성
    - 이렇게 만든 해쉬를 `base64`형태로 나타냄.
    - 구조
        
        
    - 방식
        1. JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달.
        2. 서버가 가지고있는 개인키로 Signature를 복호화
        3.  `base64UrlEncode(header)`가 JWT의 heaer값과 일치하는지 확인
        4. `base64UrlEncode(payload)` 와 일치하는지 확인하여 일치한다면 인증을 허용
